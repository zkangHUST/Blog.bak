---
title: 记一个输入缓冲bug
date: 2019-03-15 09:21:45
tags: C++
---
在论坛上看到一个同学贴的一段代码如下：
```c++
#include<stdio.h>
int main()
{
    int num, cnt, sum = 0;
    cnt = scanf("%d", &num);
    while (cnt != 1) {
        printf("cnt = %d\n", cnt);
        cnt = scanf("%d", &num);
    }
    return 0;
}
```
<!-- more -->
这段代码运行的时候，如果从键盘输入`a`回车，程序就陷入一个死循环出不来了。他非常费解，在`while`循环里面不是用了`scanf`函数吗？`scanf`应该等待用户的输入，怎么会陷入死循环呢？

造成死循环的原因是因为他没有完全理解输入缓冲区的概念。`scanf`函数的执行过程是从标准输入（通常是键盘）读取数据并放到输入缓冲区内，然后根据函数传入的参数，从缓冲区中读取相应类型的数据写入变量，返回值是从输入缓冲区读取成功的数据个数，如果读取失败，则返回0。`%d`是希望从输入缓冲区中读取一个`int`类型的数据。当输入`a`的时候，`scanf`读取整型失败，函数返回0。注意，这个时候输入缓冲区里面的内容并没有被清空，输入的两个字符`"a\n"`还在缓冲区内呢。因此进入`while`循环之后，首先打印出`cnt`的值，然后再次从缓冲区读取整型数据，这个时候缓冲区内还是有内容的，因此不会从键盘读入，然而不出意外的，再次失败，返回0。由于缓冲区内的内容一直没有被清空，因此不会继续从键盘读入，而读取整型数据又一直失败，因此造成死循环。